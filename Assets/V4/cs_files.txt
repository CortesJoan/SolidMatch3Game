File: Board.cs 
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using DG.Tweening;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;

public class Board : MonoBehaviour
{
    public int width;
    public int height;
    public GameObject tilePrefab;
    public GameObject[] tiles;
    public UnityEvent onMatchStart = new UnityEvent();
    public UnityEvent onMatch = new UnityEvent();
    public UnityEvent onBoardRefillComplete = new UnityEvent();
    public UnityEvent onBoardTileIsdestroyed = new UnityEvent();
    public int refillType;

    [SerializeField] internal Tile[,] tileMatrix;

    private MatchChecker matchChecker;
    private TileManager tileManager;
    private BoardRefiller boardRefiller;
    private BoardCommandManager boardCommandManager;
    [Header("Animation Settings")]
    [SerializeField]
    internal float swapDuration = 0.5f;
    [SerializeField] private float waitForRefillDelay = 0.5f;
    [SerializeField] private float matchClearTime = 0.5f;

    [Header("Debug")] [SerializeField] internal List<Tile> prechargedTiles = new List<Tile>();

    [Header("Hint")] private Tile hintTile;

    [SerializeField] InputHandler inputHandler;

    private void OnEnable()
    {
        inputHandler.onNoInputForLongTime.AddListener(ShowHint);
        inputHandler.onInputAfterNoInputForLongTime.AddListener(HideHint);
    }

    private void OnDisable()
    {
        inputHandler.onNoInputForLongTime.RemoveListener(ShowHint);
        inputHandler.onInputAfterNoInputForLongTime.RemoveListener(HideHint);
    }

    public void Awake()
    {
        if (tileMatrix == null || tileMatrix.Length == 0)
        {
            tileMatrix = new Tile[width, height];
        }
        if (prechargedTiles.Count != 0)
            LoadPrechargedTiles();
        matchChecker = new MatchChecker(tileMatrix, width, height);
        boardCommandManager = GetComponent<BoardCommandManager>();
        if (!boardCommandManager)
        {
            boardCommandManager = gameObject.AddComponent<BoardCommandManager>();
        }
        tileManager = new TileManager(tileMatrix, tilePrefab, tiles, swapDuration, transform);
        boardRefiller = new BoardRefiller(tileMatrix, tilePrefab, tiles, width, height, transform);

        boardCommandManager.CreateNewCommandGroup("InitializeBoard");
        InitializeBoard();


        boardCommandManager.CreateNewCommandGroup("MovementInputStart");
    }

    public void LoadPrechargedTiles()
    {
        for (int row = 0; row < width; row++)
        {
            for (int column = 0; column < height; column++)
            {
                int index = row * height + column;
                if (index < prechargedTiles.Count)
                {
                    tileMatrix[row, column] = prechargedTiles[index];
                }
                else
                {
                    break;
                }
            }
        }
    }

    private void InitializeBoard()
    {
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < height; j++)
            {
                if (tileMatrix[i, j] == null)
                {
                    tileManager.CreateAndSetUpTile(i, j);
                }
            }
        }
    }


    public List<Tile> CheckForMatchesAt(int x, int y)
    {
        return matchChecker.CheckForMatchesAt(x, y);
    }


    public IEnumerator SwapTiles(Tile tileA, Tile tileB)
    {
        boardCommandManager.CreateNewCommandGroup("SwapTiles");
        int tileAX = tileA.x;
        int tileAY = tileA.y;
        int tileBX = tileB.x;
        int tileBY = tileB.y;

        yield return StartCoroutine(tileManager.SwapTiles(tileA, tileB));

        List<Tile> newMatches = matchChecker.CheckForMatchesAt(tileA.x, tileA.y);
        List<Tile> newMatchesB = matchChecker.CheckForMatchesAt(tileB.x, tileB.y);
        newMatches.AddRange(newMatchesB);
        if (newMatches.Count > 0)
        {
            onMatchStart.Invoke();
            ClearMatches(newMatches);
            yield return new WaitForSeconds(waitForRefillDelay);
            onBoardRefillComplete.Invoke();
            yield return StartCoroutine(RefillBoard());
        }
        else
        {
            // Swap tiles' positions in the matrix
            tileMatrix[tileAX, tileAY] = tileB;
            tileMatrix[tileBX, tileBY] = tileA;

            // Update tile coordinates
            tileA.x = tileBX;
            tileA.y = tileBY;
            tileB.x = tileAX;
            tileB.y = tileAY;


            tileA.MoveToPosition(tileAX, tileAY, swapDuration);
            tileB.MoveToPosition(tileBX, tileBY, swapDuration);

            // Wait for the reverse swap to complete
            yield return new WaitForSeconds(swapDuration);

            // Swap tiles' positions in the matrix back to the original
            tileMatrix[tileAX, tileAY] = tileA;
            tileMatrix[tileBX, tileBY] = tileB;

            // Restore the original tile coordinates
            tileA.x = tileAX;
            tileA.y = tileAY;
            tileB.x = tileBX;
            tileB.y = tileBY;
        }
    }

    public void ClearMatches(List<Tile> matches)
    {
        foreach (Tile tile in matches)
        {
            boardCommandManager.AddAndDoCommandToTheLastGroup(new CommandDestroy(tile,
                matchClearTime, delegate { }));
        }
    }

    public IEnumerator RefillBoard()
    {
        yield return StartCoroutine(boardRefiller.RefillBoard(refillType));

        List<Tile> newMatches = matchChecker.FindAllMatches();
        if (newMatches.Count > 0)
        {
            onMatch?.Invoke();
            ClearMatches(newMatches);
            yield return new WaitForSeconds(waitForRefillDelay);
            StartCoroutine(RefillBoard());
        }
    }

    public bool AreTilesAdjacent(Tile tileA, Tile tileB)
    {
        int deltaX = Mathf.Abs(tileA.x - tileB.x);
        int deltaY = Mathf.Abs(tileA.y - tileB.y);

        return (deltaX == 1 && deltaY == 0) || (deltaX == 0 && deltaY == 1);
    }

    public UnityEvent<int, int> onTileMatchFound => matchChecker.OnTileMatchFound;

    public TileManager GetTileManager()
    {
        return tileManager;
    }

    public Tile[,] GetTileMatrix()
    {
        return tileMatrix;
    }

    public void SetTileMatrix(Tile[,] newMatrix)
    {
        tileMatrix = newMatrix;
    }

    Tile FindHintTile()
    {
        // Loop through all tiles in the board
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < height; j++)
            {
                // Get the current tile
                Tile tile = tileMatrix[i, j];
                if (tile == null || !tile.IsFullySpawned()) continue;

                // Check if swapping with the right tile creates a match
                if (i < width - 1 && AreTilesAdjacent(tile, tileMatrix[i + 1, j]))
                {
                    // Swap the tiles temporarily
                    SwapTilesInMatrix(tile, tileMatrix[i + 1, j]);
                    // Check for matches at the swapped positions
                    List<Tile> matches = CheckForMatchesAt(i + 1, j);
                    List<Tile> matchesB = CheckForMatchesAt(i, j);
                    matches.AddRange(matchesB);
                    // Swap the tiles back to the original positions
                    SwapTilesInMatrix(tile, tileMatrix[i + 1, j]);
                    // If there are matches, return the current tile as a hint
                    if (matches.Count > 0)
                    {
                        return tile;
                    }
                }

                // Check if swapping with the upper tile creates a match
                if (j < height - 1 && AreTilesAdjacent(tile, tileMatrix[i, j + 1]))
                {
                    // Swap the tiles temporarily
                    SwapTilesInMatrix(tile, tileMatrix[i, j + 1]);
                    // Check for matches at the swapped positions
                    List<Tile> matches = CheckForMatchesAt(i, j + 1);
                    List<Tile> matchesB = CheckForMatchesAt(i, j);
                    matches.AddRange(matchesB);
                    // Swap the tiles back to the original positions
                    SwapTilesInMatrix(tile, tileMatrix[i, j + 1]);
                    // If there are matches, return the current tile as a hint
                    if (matches.Count > 0)
                    {
                        return tile;
                    }
                }
            }
        }
        // If no matches are found, return null
        return null;
    }

    private void SwapTilesInMatrix(Tile tileA, Tile tileB)
    {
        int tileAX = tileA.x;
        int tileAY = tileA.y;
        int tileBX = tileB.x;
        int tileBY = tileB.y;

// Swap tiles' positions in the matrix
        tileMatrix[tileAX, tileAY] = tileB;
        tileMatrix[tileBX, tileBY] = tileA;

// Update tile coordinates
        tileA.x = tileBX;
        tileA.y = tileBY;
        tileB.x = tileAX;
        tileB.y = tileAY;
    }

    Color originalColor = Color.white;

    private void ShowHint()
    {
        // Find a hint tile
        hintTile = FindHintTile();
        if (hintTile == null) return;
        originalColor = hintTile.GetComponentInChildren<SpriteRenderer>().color;
// Highlight the hint tile by changing its color or adding an effect
        hintTile.GetComponentInChildren<SpriteRenderer>().color = Color.yellow;

// TODO: Add any other logic for showing the hint, such as playing a sound or showing an animation
    }

    private void HideHint()
    {
        if (hintTile == null) return;
        hintTile.GetComponentInChildren<SpriteRenderer>().color = originalColor;


// TODO: Add any other logic for hiding the hint, such as stopping an effect or animation
    }
} 
File: BoardCommandManager.cs 
﻿using System;
using System.Collections.Generic;
using UnityEngine;

public class BoardCommandManager : MonoBehaviour
{
    private Board board;

    [SerializeReference] private List<GroupCommand> groupCommands;

    [SerializeReference, SubclassSelector] private List<Command> performedCommands;
    public static BoardCommandManager instance;

    private void Awake()
    {
        instance = this;
        InitializeHistory();
    }

    void InitializeHistory()
    {
        board = GetComponent<Board>();
        performedCommands = new List<Command>();
        groupCommands = new List<GroupCommand>();
    }

    void AddCommand(Command command)
    {
        performedCommands.Add(command);
    }

    void DoCommand(int commandIndex)
    {
        if (commandIndex < 0 || commandIndex >= performedCommands.Count)
        {
            return;
        }
        performedCommands[commandIndex].DoCommand();
    }

    void UndoLastCommand()
    {
        if (performedCommands.Count == 0)
        {
            return;
        }
        performedCommands[^1].UndoCommand();
        performedCommands.Remove(performedCommands[^1]);
    }

    public void UndoLastGroupCommand()
    {
        if (performedCommands.Count == 0 || groupCommands.Count == 0)
        {
            return;
        }
        var groupCommand = groupCommands[^1];
        groupCommand.UndoCommandsInGroup();
        foreach (var command in groupCommand.GetCommandsInGroup())
        {
            performedCommands.Remove(command);
        }
        groupCommands.Remove(groupCommand);
    }

    public void AddAndDoCommand(Command command)
    {
        performedCommands.Add(command);
        command.DoCommand();
    }

    public void AddAndDoCommandToTheLastGroup(Command command)
    {
        groupCommands[^1].AddCommandToGroup(command);
        performedCommands.Add(command);
        command.DoCommand();
    }

    public void CreateNewCommandGroup(string name)
    {
        groupCommands.Add(new GroupCommand(name));
    }
}      
File: BoardRefiller.cs 
﻿using System.Collections;
using DG.Tweening;
using UnityEngine;
using UnityEngine.Events;

public class BoardRefiller
{
    private Tile[,] _tileMatrix;
    private GameObject _tilePrefab;
    private GameObject[] _tiles;
    private int _width, _height;
    private Transform _parentTransform;
    public  static UnityEvent<Tile> onTileFullSpawn = new UnityEvent<Tile>();

    public BoardRefiller(Tile[,] tileMatrix, GameObject tilePrefab, GameObject[] tiles, int width, int height,
        Transform parentTransform)
    {
        _tileMatrix = tileMatrix;
        _tilePrefab = tilePrefab;
        _tiles = tiles;
        _width = width;
        _height = height;
        _parentTransform = parentTransform;
    }

    public IEnumerator RefillBoard(int refillType)
    {
        // Wait for tiles to settle
        yield return new WaitForSeconds(0.5f);

        switch (refillType)
        {
            case 1:
                SpawnNewTiles();
                break;
            case 2:
                MakeTilesFallIntoEmptySpacesAndSpawnNewTiles();
                break;
            default:
                Debug.LogError("Invalid refillType provided.");
                break;
        }
    }

    private void SpawnNewTiles()
    {
        for (int i = 0; i < _width; i++)
        {
            for (int j = 0; j < _height; j++)
            {
                if (_tileMatrix[i, j] == null)
                {
                    int randomTile = GetRandomTileIndex(i, j);
                    BoardCommandManager.instance.AddAndDoCommand(new CommandCreateTile(this,    GameObject.FindObjectOfType<Board>().GetTileManager(), i, j, randomTile)); 
                }
            }
        }
    }

    internal Tile SpawnNewRandomTileAt(int x, int y)
    {
        GameObject newTile = Object.Instantiate(_tilePrefab,  _parentTransform);
        newTile.transform.localPosition = new Vector2(x, y);
        newTile.transform.SetParent(_parentTransform);
        int randomTile = GetRandomTileIndex(x, y);
        SetTileSprite(newTile, randomTile);

        Tile tileComponent = newTile.GetComponent<Tile>();
        tileComponent.Init(x, y, randomTile);
        _tileMatrix[x, y] = tileComponent;

        newTile.transform.DOScale(Vector3.zero, 0.5f).From().OnComplete(() =>
        {
            _tileMatrix[x, y].SetIsFullySpawned(true);
            onTileFullSpawn?.Invoke(tileComponent);
        });
        return _tileMatrix[x, y];
    }

    private int GetRandomTileIndex(int x, int y)
    {
        int randomTile;

        do
        {
            CommandSaveLoadRandomState commandSaveLoadRandomState =  new CommandSaveLoadRandomState(0, _tiles.Length);
            BoardCommandManager.instance.AddAndDoCommandToTheLastGroup(commandSaveLoadRandomState);
            randomTile =commandSaveLoadRandomState.result;
        } while (CreatesInitialMatch(x, y, randomTile));

        return randomTile;
    }

    private bool CreatesInitialMatch(int x, int y, int tileType)
    {
        if (x > 1 && tileType == _tileMatrix[x - 1, y]?.tileType && tileType == _tileMatrix[x - 2, y]?.tileType)
        {
            return true;
        }

        if (y > 1 && tileType == _tileMatrix[x, y - 1]?.tileType && tileType == _tileMatrix[x, y - 2]?.tileType)
        {
            return true;
        }

        return false;
    }

    private void SetTileSprite(GameObject tileObject, int tileIndex)
    {
        SpriteRenderer renderer = tileObject.GetComponentInChildren<SpriteRenderer>();
        renderer.sprite = _tiles[tileIndex].GetComponentInChildren<SpriteRenderer>().sprite;
    }

    private void MakeTilesFallIntoEmptySpacesAndSpawnNewTiles()
    {
        for (int x = 0; x < _width; x++)
        {
            float fallDelay = 0;
            for (int y = 0; y < _height; y++)
            {
                if (_tileMatrix[x, y] == null)
                {
                    int newY = y;
                    while (newY < _height - 1 && _tileMatrix[x, newY] == null)
                    {
                        newY++;
                    }

                    if (newY < _height - 1)
                    {
                        _tileMatrix[x, newY].MoveToPosition(x, y, 0.5f);
                        _tileMatrix[x, newY].y = y;
                        _tileMatrix[x, y] = _tileMatrix[x, newY];
                        _tileMatrix[x, newY] = null;

                        fallDelay += 0.1f;
                    }
                    else
                    {
                        SpawnNewRandomTileAt(x, _height - 1);
                        _tileMatrix[x, _height - 1].transform.position = new Vector3(x, _height, 0);
                        _tileMatrix[x, _height - 1].MoveToPosition(x, y, 0.5f);
                        _tileMatrix[x, _height - 1].y = y;
                        _tileMatrix[x, y] = _tileMatrix[x, _height - 1];
                    }
                }
            }
        }
    }
} 
File: Command.cs 
﻿using System;
using UnityEngine.Events;

[Serializable]
public abstract  class Command
{
  public UnityEvent onDoCommand = new UnityEvent();

  public Command(UnityAction onDoCommand = null)
  {
    this.onDoCommand.AddListener(onDoCommand);
  }
  public virtual void DoCommand(bool force = false)
  {
    onDoCommand?.Invoke();
  }
  public abstract void UndoCommand(bool force=false);

} 
File: CommandAddScore.cs 
﻿using System;

[Serializable]
public class CommandAddScore : Command
{
    private GameModel gameModel;
    private int scoreValue;

    public CommandAddScore(GameModel gameModel, int scoreValue)
    {
        this.gameModel = gameModel;
        this.scoreValue = scoreValue;
    }

    public override void DoCommand(bool force = false)
    {
        gameModel.AddScore(scoreValue);
    }

    public override void UndoCommand(bool force = false)
    {
        gameModel.AddScore(-scoreValue);
    }
} 
File: CommandBoardRefill.cs 
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class CommandBoardRefill : Command
{
    private BoardRefiller boardRefiller;
    private int refillType;
    private List<Tile> affectedTiles;
    private List<Vector2Int> originalPositions;

    public CommandBoardRefill(BoardRefiller boardRefiller, int refillType)
    {
        this.boardRefiller = boardRefiller;
        this.refillType = refillType;
        affectedTiles = new List<Tile>();
        originalPositions = new List<Vector2Int>();
        BoardRefiller.onTileFullSpawn.AddListener(OnTileFullSpawn);
    }

    public override void DoCommand(bool force = false)
    {
        boardRefiller.RefillBoard(refillType);
    }

    public override void UndoCommand(bool force = false)
    {
        for (int i = 0; i < affectedTiles.Count; i++)
        {
            Tile tile = affectedTiles[i];
            Vector2Int originalPosition = originalPositions[i];
            int currentX = tile.x;
            int currentY = tile.y;
            tile.MoveToPosition(originalPosition.x, originalPosition.y, 0.5f);
            Board board = GameObject.FindObjectOfType<Board>();
            board.tileMatrix[currentX, currentY] = null;
            board.tileMatrix[originalPosition.x, originalPosition.y] = tile;
            tile.x = originalPosition.x;
            tile.y = originalPosition.y;
        }
    }

    private void OnTileFullSpawn(Tile spawnedTile)
    {
        affectedTiles.Add(spawnedTile);
        originalPositions.Add(new Vector2Int(-1, -1));
    }
} 
File: CommandCreateTile.cs 
﻿using System;
using DG.Tweening;
using UnityEngine;

[Serializable]
public class CommandCreateTile : Command
{
    private BoardRefiller boardRefiller;
    private TileManager tileManager;
    private int xPos, yPos;
    private int tileType;
    private Tile createdTile;

    public CommandCreateTile(BoardRefiller boardRefiller,TileManager tileManager, int xPos, int yPos, int tileType)
    {
        this.tileManager = tileManager;
        this.boardRefiller = boardRefiller;
        this.xPos = xPos;
        this.yPos = yPos;
        this.tileType = tileType;
    }

    public override void DoCommand(bool force = false)
    {
        createdTile = boardRefiller.SpawnNewRandomTileAt(xPos, yPos);
        createdTile.tileType = tileType;
        tileManager.SetTileSprite(createdTile.gameObject, tileType);
    }

    public override void UndoCommand(bool force = false)
    {
        TileDestructionEffect destructionEffect = GameObject.FindObjectOfType<TileDestructionEffect>();
        destructionEffect.Play(createdTile.transform.position);
        createdTile.transform.DOScale(Vector3.zero, .5f)
            .OnComplete(() =>
            {
                GameObject.Destroy(createdTile.gameObject);
                Board board = GameObject.FindObjectOfType<Board>();
                board.tileMatrix[createdTile.x, createdTile.y] = null;
            });
    }
} 
File: CommandDestroy.cs 
﻿using System;
using DG.Tweening;
using UnityEngine;
using UnityEngine.Events;

[Serializable]

public class CommandDestroy : Command
{
    private Tile tileToDestroy;
    private int tileTypeBeforeDestroy;
    private float destructionEffectDuration;
    private Vector2Int positionBeforeDestroy;
    public CommandDestroy(Tile tileToDestroy,float duration, UnityAction onDestroyStart=null)
    {
        this.tileToDestroy = tileToDestroy;
         this.destructionEffectDuration = duration;
        this.tileTypeBeforeDestroy = tileToDestroy.tileType;
        onDoCommand.AddListener(onDestroyStart);
    }

    public override void DoCommand(bool force = false)
    {
        tileToDestroy.transform.DOScale(Vector3.zero, destructionEffectDuration)
            .OnComplete(() =>
            {
                positionBeforeDestroy= new Vector2Int(tileToDestroy.x,tileToDestroy.y);
                Board board = GameObject.FindObjectOfType<Board>();
                board.tileMatrix[tileToDestroy.x, tileToDestroy.y] = null;
                GameObject.Destroy(tileToDestroy.gameObject);

            });
    }

    public override void UndoCommand(bool force = false)
    {
        Board board = GameObject.FindObjectOfType<Board>();
        TileManager tileManager = new TileManager(board.tileMatrix, board.tilePrefab, board.tiles, board.swapDuration,
            board.transform);
        tileManager.CreateAndSetUpTile(positionBeforeDestroy.x, positionBeforeDestroy.y);
        Tile newTile = board.tileMatrix[positionBeforeDestroy.x, positionBeforeDestroy.y];
        newTile.tileType = tileTypeBeforeDestroy;
        tileManager.SetTileSprite(newTile.gameObject, tileTypeBeforeDestroy);
        newTile.transform.localScale = Vector3.zero;
        newTile.transform.DOScale(Vector3.one, destructionEffectDuration)
            .OnComplete(() => { newTile.SetIsFullySpawned(true); });
    }
} 
File: CommandMove.cs 
﻿using System;
using UnityEngine;
[Serializable]

public class CommandMove : Command
{
    private Tile tileToMove;
    private int originalX, originalY;
    private int newX, newY;
    private float moveDuration;

    public CommandMove(Tile tileToMove, int newX, int newY, float duration)
    {
        this.tileToMove = tileToMove;
        this.newX = newX;
        this.newY = newY;
        this.moveDuration = duration;
        this.originalX = tileToMove.x;
        this.originalY = tileToMove.y;
    }

    public override void DoCommand(bool force = false)
    {
        tileToMove.MoveToPosition(newX, newY, moveDuration);
        Board board = GameObject.FindObjectOfType<Board>();
        board.tileMatrix[originalX, originalY] = null;
        board.tileMatrix[newX, newY] = tileToMove;
        tileToMove.x = newX;
        tileToMove.y = newY;
    }

    public override void UndoCommand(bool force = false)
    {
        tileToMove.MoveToPosition(originalX, originalY, moveDuration);
        Board board = GameObject.FindObjectOfType<Board>();
        board.tileMatrix[newX, newY] = null;
        board.tileMatrix[originalX, originalY] = tileToMove;
        tileToMove.x = originalX;
        tileToMove.y = originalY;
    }
} 
File: CommandSaveLoadRandomState.cs 
﻿using System;
using Random = UnityEngine.Random;

[Serializable]

public class CommandSaveLoadRandomState : Command
{
    private Random.State previousState;
    private Random.State currentState;

    public int minInclusive, maxExclusive;

    public int result;

    public CommandSaveLoadRandomState(int min, int max)
    {
        previousState = Random.state;
        minInclusive = min;
        maxExclusive = max;
        currentState = previousState;
    }

    public override void DoCommand(bool force = false)
    {
        result = Random.Range(minInclusive, maxExclusive);
        currentState = Random.state;
    }

    public override void UndoCommand(bool force = false)
    {
        Random.state = previousState;
        currentState = previousState;
        result = 0;
    }
} 
File: CommandSpawnTile.cs 
﻿using System;
using DG.Tweening;
using UnityEngine;
[Serializable]

public class CommandSpawnTile :Command
{
     private Tile tileToDestroy;
     private int tileTypeBeforeDestroy;
      private float destructionEffectDuration;
 int xPos, yPos;
    public CommandSpawnTile(Tile tileToSpawn,int xPos,int yPos,  float duration, BoardRefiller boardRefiller)
    {
        boardRefiller.SpawnNewRandomTileAt(xPos, yPos);
         this.tileToDestroy = tileToDestroy;
         this.destructionEffectDuration = duration;
         this.tileTypeBeforeDestroy = tileToDestroy.tileType;
    }

    public override void DoCommand(bool force = false)
    {
        tileToDestroy.transform.DOScale(Vector3.zero, destructionEffectDuration)
            .OnComplete(() =>
            {
                GameObject.Destroy(tileToDestroy.gameObject);
                Board board = GameObject.FindObjectOfType<Board>();
                board.tileMatrix[tileToDestroy.x, tileToDestroy.y] = null;
            });
    }

    public override void UndoCommand(bool force = false)
    {
         Board board = GameObject.FindObjectOfType<Board>();
        TileManager tileManager = new TileManager(board.tileMatrix, board.tilePrefab, board.tiles, board.swapDuration,
            board.transform);
        tileManager.CreateAndSetUpTile(tileToDestroy.x, tileToDestroy.y);
         Tile newTile = board.tileMatrix[tileToDestroy.x, tileToDestroy.y];
        newTile.tileType = tileTypeBeforeDestroy;
        tileManager.SetTileSprite(newTile.gameObject, tileTypeBeforeDestroy);
         newTile.transform.localScale = Vector3.zero;
        newTile.transform.DOScale(Vector3.one, destructionEffectDuration)
            .OnComplete(() => { newTile.SetIsFullySpawned(true); });
    }
} 
File: GameController.cs 
using UnityEngine;

public class GameController : MonoBehaviour
{
    public static GameController Instance;
    public GameModel model;
    public GameView view;

    private int currentLevel = 0;
    private int currentRandomSeed;
    [Header("Timers")] [SerializeField] private float checkConditionInterval = 1f;
    private float elapsedTime = 0;

    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        InitializeLevel(currentLevel);
        view.inputHandler.onTilesSwapped.AddListener(OnTilesSwapped);
        view.board.onMatch.AddListener(OnMatch);
        view.board.onMatchStart.AddListener(OnMatchStart);
        view.board.onBoardRefillComplete.AddListener(OnBoardRefillComplete);
        model.OnScoreChanged.AddListener((s) => CheckGameState());
        view.OnTileMatchFound.AddListener(OnTileMatchFound);
        currentRandomSeed = UnityEngine.Random.seed;

        elapsedTime = 0f;
    }

    public void InitializeLevel(int levelIndex)
    {
        currentLevel = levelIndex;
        LevelObjective objective = model.levels[currentLevel];
        model.moves = objective.maxMoves;
        model.totalTime = objective.maxTime;
        model.remainingTime = model.totalTime;
        model.score = 0;
        model.SetComboMultiplier(1);
    }

    void Update()
    {
        if (model.remainingTime > 0)
        {
            model.remainingTime -= Time.deltaTime;
        }
        else
        {
            model.remainingTime = 0;
        }
        CheckGameState();
        CheckLoseCondition();
    }

    public void OnGameOver()
    {
        Debug.Log("You lost");
        // TODO: Display "Game Over" message or other related GUI
    }


    public void IncreaseCombo()
    {
        model.SetComboMultiplier(model.GetComboMultiplier() + 1);
    }

    public void ResetCombo()
    {
        model.SetComboMultiplier(1);
    }

    public void OnTilesSwapped(Tile tileA, Tile tileB)
    {
        StartCoroutine(view.board.SwapTiles(tileA, tileB));
        model.ConsumeMove();
        CheckGameState();
    }

    void OnMatchStart()
    {
        // Implement any logic needed on a match start, e.g. play a sound effect or show an animation
    }

    void OnBoardRefillComplete()
    {
        // Implement any logic needed when the board refilling is completed, e.g. update UI or check for win/lose conditions
    }

    private void CheckGameState()
    {
        CheckWinCondition();
        CheckLoseCondition();
    }

    private void CheckWinCondition()
    {
        LevelObjective levelObjective = model.levels[model.currentLevel];

        // Check if all victory conditions are met
        bool allConditionsMet = true;
        foreach (VictoryCondition condition in levelObjective.victoryConditions)
        {
            if (!condition.IsConditionMet(model))
            {
                allConditionsMet = false;
                break;
            }
        }

        if (allConditionsMet)
        {
            OnLevelComplete();
        }
    }

    private void OnLevelComplete()
    {
        // Implement logic for moving to the next level or showing a "Level Complete" message
        if (model.currentLevel < model.levels.Length - 1)
        {
            model.currentLevel++;
            InitializeLevel(model.currentLevel);
        }
        else
        {
            // Game completed (all levels completed)
        }
    }

    private void CheckLoseCondition()
    {
        LevelObjective levelObjective = model.levels[model.currentLevel];
        foreach (LoseCondition loseCondition in levelObjective.loseConditions)
        {
            if (loseCondition.IsConditionMet(model))
            {
                OnGameOver();
                break;
            }
        }
    }

    void OnTileMatchFound(int tileType, int numOfMatchedTiles)
    {
        // Handle the matched tiles in this method.
        // Example: Add score based on the number of matched tiles and tile type
    }
    

    private void OnMatch()
    {
        IncreaseCombo();
    }
} 
File: GameModel.cs 
﻿using UnityEngine;
using UnityEngine.Events;


public class GameModel : MonoBehaviour
{
    public int score;
    public int moves;
   [SerializeField] private int comboMultiplier;
    public int currentLevel;
    
    public LevelObjective[] levels;
    public float totalTime;
    public float remainingTime;
    public UnityEvent<int> OnScoreChanged;
    public UnityEvent<int,int> OnTileMatchFound;
    
    public int CurrentLevel => currentLevel;

    public void ResetComboMultiplier()
    {
        comboMultiplier = 1;
    }

    public void IncreaseComboMultiplier()
    {
        comboMultiplier++;
    }
    public void ConsumeMove()
    {
        moves--;
        comboMultiplier = 1;
    }
    public void AddScore(int value)
    {
        score += value * comboMultiplier;
        OnScoreChanged.Invoke(score);
    }
   
    public int GetScore()
    {
        return score;
    }

    public void SetScore(int value)
    {
        score = value;
    }

    public int GetMoves()
    {
        return moves;
    }

    public void SetMoves(int value)
    {
        moves = value;
    }

    public int GetComboMultiplier()
    {
        return comboMultiplier;
    }

    public void SetComboMultiplier(int value)
    {
        comboMultiplier = value;
    }
} 
File: GameView.cs 
﻿using UnityEngine;
using UnityEngine.Events;

public class GameView : MonoBehaviour
{
    public Board board;
    public UIManager uiManager;
    public InputHandler inputHandler;

    // The rest of the GameView methods will use board, uiManager and inputHandler
    // to manage visuals, animations, UI-events as well as any other UI-related tasks
    
    
    public UnityEvent<int,int> OnTileMatchFound
    {
        get { return board.onTileMatchFound; }
    }
} 
File: GroupCommand.cs 
﻿using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class GroupCommand
{
    [SerializeField] private string commandGroupName;
    [SerializeReference, SubclassSelector] private List<Command> commandsInGroup;
    public GroupCommand(string name)
    {
        commandGroupName = name;
        commandsInGroup = new List<Command>();
    }

    public List<Command> GetCommandsInGroup()
    {
        return commandsInGroup;
    }

    public void AddCommandToGroup(Command command)
    {
        commandsInGroup.Add(command);
    }

    public void RemoveCommandFromGroup(Command command)
    {
        commandsInGroup.Remove(command);
    }

    public void UndoCommandsInGroup(bool fast=false)
    {
        for (var index = commandsInGroup.Count - 1; index >= 0; index--)
        {
            var command = commandsInGroup[index];
            command.UndoCommand(fast);
        } 
    }
} 
File: InputHandler.cs 
﻿using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.InputSystem;
using UnityEngine.Serialization;

public class InputHandler : MonoBehaviour
{
    public UnityEvent<Tile, Tile> onTilesSwapped;
    private Board board;
    private Tile selectedTile;
    private Camera mainCamera;
    [SerializeField]private float maxTimeWithoutInput = 3f;
    private float currentTimeWithoutInput;
    public UnityEvent onNoInputForLongTime;
    public UnityEvent onInputAfterNoInputForLongTime;

    void Awake()
    {
        if (onTilesSwapped == null)
        {
            onTilesSwapped = new UnityEvent<Tile, Tile>();
        }
    }

    void Start()
    {
        board = FindObjectOfType<Board>();
        mainCamera = Camera.main;
    }

    void Update()
    {
        if (Touchscreen.current != null && Touchscreen.current.primaryTouch.press.wasPressedThisFrame)
        {
            Vector2 touchPosition =
                mainCamera.ScreenToWorldPoint(Touchscreen.current.primaryTouch.position.ReadValue());
            HandleInput(touchPosition);
        }

        if (Mouse.current.leftButton.wasPressedThisFrame)
        {
            Vector2 mousePosition = mainCamera.ScreenToWorldPoint(Mouse.current.position.ReadValue());
            HandleInput(mousePosition);
        }
        currentTimeWithoutInput = Mathf.Min(currentTimeWithoutInput + Time.deltaTime, maxTimeWithoutInput);
        if (currentTimeWithoutInput == maxTimeWithoutInput)
        {
            onNoInputForLongTime?.Invoke();
            currentTimeWithoutInput = 0;
        }
    }

    private void HandleInput(Vector2 position)
    {
        if (currentTimeWithoutInput!=0)
        {
            onInputAfterNoInputForLongTime?.Invoke();
        }
        RaycastHit2D hit = Physics2D.Raycast(position, Vector2.zero);
        if (hit.collider != null)
        {
            Tile selectedTile = hit.collider.GetComponentInParent<Tile>();
            SelectTile(selectedTile);
        }
    }

    private void SelectTile(Tile tile)
    {
        if (tile == null || !tile.IsFullySpawned()) return;
        if (selectedTile == null)
        {
            selectedTile = tile;
        }
        else
        {
            if (board.AreTilesAdjacent(selectedTile, tile))
            {
                onTilesSwapped.Invoke(selectedTile, tile);
                selectedTile = null;
            }
            else
            {
                selectedTile = tile;
            }
        }
    }
} 
File: LevelObjective.cs 
﻿[System.Serializable]
public class LevelObjective
{
    public VictoryCondition[] victoryConditions;
    public LoseCondition[] loseConditions;

    public int targetScore;
    public int maxMoves;
    public float maxTime;
    public int refillType; // 1: Spawn new tiles, 2: Falling tiles from above

} 
File: LimitedMovesVictoryCondition.cs 
﻿using UnityEngine;

[CreateAssetMenu(menuName = "VictoryCondition/LimitedMoves")]
public class LimitedMovesVictoryCondition : VictoryCondition
{
    public int maxMoves;

    public override bool IsConditionMet(GameModel model)
    {
        return model.score >= model.levels[model.currentLevel].targetScore && model.moves >= 0;
    }
} 
File: LoseCondition.cs 
﻿using UnityEngine;

public abstract class LoseCondition :ScriptableObject
{
    public abstract bool IsConditionMet(GameModel model);
} 
File: MatchChecker.cs 
﻿using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class MatchChecker
{
    private Tile[,] _tileMatrix;
    private int _width;
    private int _height;
    public UnityEvent<int, int> OnTileMatchFound = new UnityEvent<int, int>();
    public MatchChecker(Tile[,] tileMatrix, int width, int height)
    {
        _tileMatrix = tileMatrix;
        _width = width;
        _height = height;
        OnTileMatchFound = new UnityEvent<int, int>();
        BoardRefiller.onTileFullSpawn.AddListener(OnTileFullSpawns);
    }

    private void OnTileFullSpawns(Tile spawnedTile)
    {
        CheckForMatchesAt(spawnedTile.x, spawnedTile.y);
        
    }

    public List<Tile> CheckForMatchesAt(int x, int y)
    {
        Tile tile = _tileMatrix[x, y];
        if (tile  == null || !tile.IsFullySpawned())
        {
            Debug.LogWarning("Not tile at pos x: " + x + " y: " + y);
            return new List<Tile>();
        }

        List<Tile> matchedTiles = new List<Tile>();

        List<Tile> horizontalMatches = CheckHorizontalMatchesAt(x, y);
        List<Tile> verticalMatches = CheckVerticalMatchesAt(x, y);

        if (horizontalMatches.Count > 0)
        {
            matchedTiles.Add(_tileMatrix[x, y]);
            matchedTiles.AddRange(horizontalMatches);
        }

        if (verticalMatches.Count > 0)
        {
            if (!matchedTiles.Contains(_tileMatrix[x, y]))
            {
                matchedTiles.Add(_tileMatrix[x, y]);
            }
            matchedTiles.AddRange(verticalMatches);
        }

        return matchedTiles;
    }

    private List<Tile> CheckHorizontalMatchesAt(int x, int y)
    {
        List<Tile> leftMatches = CheckMatchesInDirection(x, y, Vector2.left);
        List<Tile> rightMatches = CheckMatchesInDirection(x, y, Vector2.right);
        List<Tile> horizontalMatches = new List<Tile>(leftMatches);
        horizontalMatches.AddRange(rightMatches);

        if (GetTileAt(x,y).GetMinimumTileCountForMatch()<=horizontalMatches.Count+1)
        {
         
            return horizontalMatches;
            
        }
        return new List<Tile>();
    }
    
    private List<Tile> CheckVerticalMatchesAt(int x, int y)
    {
        List<Tile> upMatches = CheckMatchesInDirection(x, y, Vector2.up);
        List<Tile> downMatches = CheckMatchesInDirection(x, y, Vector2.down);
        List<Tile> verticalMatches = new List<Tile>(upMatches);
        verticalMatches.AddRange(downMatches);

        if (GetTileAt(x,y).GetMinimumTileCountForMatch()<= verticalMatches.Count+1)
        {
         
            return verticalMatches;
            
        }
        return new List<Tile>();
    }

    private List<Tile> CheckMatchesInDirection(int x, int y, Vector2 direction)
    {
        List<Tile> matchedTiles = new List<Tile>();

        Tile currentTile = _tileMatrix[x, y];
        
        if (!currentTile || !currentTile.IsFullySpawned())
        {
            return matchedTiles;
        }
        int currentType = currentTile.tileType;

        int xOffset = (int)direction.x;
        int yOffset = (int)direction.y;

        for (int i = 1; i < Mathf.Max(_width, _height); i++)
        {
            int newX = x + xOffset * i;
            int newY = y + yOffset * i;

            if (newX >= 0 && newX < _width && newY >= 0 && newY < _height)
            {
                Tile nextTile = _tileMatrix[newX, newY];
                if (nextTile != null && nextTile.tileType == currentType)
                {
                    matchedTiles.Add(nextTile);
                }
                else
                {
                    break;
                }
            }
            else
            {
                break;
            }
        }

        return matchedTiles;
    }

    public List<Tile> FindAllMatches()
    {
        List<Tile> result = new List<Tile>();

        for (int i = 0; i < _width; i++)
        {
            for (int j = 0; j < _height; j++)
            {
                List<Tile> matches = CheckForMatchesAt(i, j);

                if (matches.Count >= 1) // Change to work with a minimum match of two tiles
                {
                    result.AddRange(matches);
                }
            }
        }

        return result;
    }
    public Tile GetTileAt(int x, int y)
    {
        if (x >= 0 && x < _width && y >= 0 && y < _height)
        {
            return _tileMatrix[x, y];
        }
        else
        {
            return null;
        }
    }
} 
File: OutOfMovesLoseCondition.cs 
﻿using UnityEngine;

[CreateAssetMenu(menuName = "LoseCondition/OutOfMoves")]
public class OutOfMovesLoseCondition : LoseCondition
{
    public override bool IsConditionMet(GameModel model)
    {
        return model.moves <= 0;
    }
} 
File: OutOfTimeLoseCondition.cs 
﻿using UnityEngine;

[CreateAssetMenu(menuName = "LoseCondition/OutOfTime")]
public class OutOfTimeLoseCondition : LoseCondition
{
    public override bool IsConditionMet(GameModel model)
    {
        return model.remainingTime <= 0;
    }
} 
File: ScoreVictoryCondition.cs 
﻿using UnityEngine;

[CreateAssetMenu(menuName = "VictoryCondition/Score")]
public class ScoreVictoryCondition : VictoryCondition
{
    public int targetScore;

    public override bool IsConditionMet(GameModel model)
    {
        return model.score >= targetScore;
    }
} 
File: Tile.cs 
﻿using System;
using DG.Tweening;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;

[Serializable]
public class Tile : MonoBehaviour
{
    public int x;
    public int y;
    public int tileType;
    [HideInInspector] [SerializeField] private bool isFullySpawned;
    [SerializeField] int numberOfSameTilesToMatch;
    [FormerlySerializedAs("onDestroy")] public UnityEvent onDestroyStart;
    public UnityEvent onDestroyFinish;
    public void Init(int xPos, int yPos, int type)
    {
        x = xPos;
        y = yPos;
        tileType = type;
    }

    public void MoveToPosition(int newX, int newY, float duration)
    {
        x = newX;
        y = newY;
        isFullySpawned = false;

        transform.DOLocalMove(new Vector2(x, y), duration)
            .OnComplete(() => { isFullySpawned = true; });
    }

    public void DestroyTile()
    {
        onDestroyStart?.Invoke();
        onDestroyFinish?.Invoke();
    }
    
    public bool IsFullySpawned()
    {
        return isFullySpawned;
    }

    public void SetIsFullySpawned(bool value)
    {
        isFullySpawned = value;
    }

    public int GetMinimumTileCountForMatch()
    {
        return numberOfSameTilesToMatch;
    }
} 
File: TileDestructionEffect.cs 
﻿using UnityEngine;

public class TileDestructionEffect : MonoBehaviour
{
    [Header("Effect Settings")]
    [SerializeField] private float destructionEffectDuration = 5f;

    private ParticleSystem particleSystem;

    private void Start()
    {
        particleSystem = GetComponent<ParticleSystem>();
        SetParticleSystemDuration();
    }

    private void SetParticleSystemDuration()
    {
        particleSystem.Stop(true, ParticleSystemStopBehavior.StopEmittingAndClear);
        var main = particleSystem.main;
        main.duration = destructionEffectDuration;
    }

    public void Play(Vector2 position)
    {
        transform.position = position;
        particleSystem.Play();
    }

    private void Update()
    {
        if (particleSystem && !particleSystem.IsAlive())
        {
            particleSystem.Clear();
            particleSystem.Stop();
        }
    }
} 
File: TileManager.cs 
﻿using System.Collections;
using UnityEngine;

public class TileManager
{
    private Tile[,] _tileMatrix;
    private GameObject _tilePrefab;
    private GameObject[] _tiles;
    private float _swapDuration;


    private Transform _parentTransform;
    private BoardCommandManager _boardCommandManager;

    public TileManager(Tile[,] tileMatrix, GameObject tilePrefab, GameObject[] tiles, float swapDuration,
        Transform parentTransform)
    {
        _tileMatrix = tileMatrix;
        _tilePrefab = tilePrefab;
        _tiles = tiles;
        _swapDuration = swapDuration;
        _parentTransform = parentTransform;
        _boardCommandManager =  parentTransform.GetComponent<BoardCommandManager>();
    }

    public void CreateAndSetUpTile(int x, int y)
    {
        GameObject newTile = Object.Instantiate(_tilePrefab, _parentTransform);
        newTile.transform.localPosition = new Vector2(x, y);
        int randomTile = GetRandomTileIndex(x, y);
        SetTileSprite(newTile, randomTile);

        _tileMatrix[x, y] = newTile.GetComponent<Tile>();
        _tileMatrix[x, y].Init(x, y, randomTile);
        _tileMatrix[x, y].SetIsFullySpawned(true); // Set IsFullySpawned to true for initial tiles
    }

    public IEnumerator SwapTiles(Tile tileA, Tile tileB)
    {
        int tileAX = tileA.x;
        int tileAY = tileA.y;
        int tileBX = tileB.x;
        int tileBY = tileB.y;
        _boardCommandManager.AddAndDoCommandToTheLastGroup(new CommandMove(tileA, tileBX, tileBY, _swapDuration));
        _boardCommandManager.AddAndDoCommandToTheLastGroup(new CommandMove(tileB, tileAX, tileAY, _swapDuration));
        _tileMatrix[tileAX, tileAY] = tileB;
        _tileMatrix[tileBX, tileBY] = tileA;
        tileA.x = tileBX;
        tileA.y = tileBY;
        tileB.x = tileAX;
        tileB.y = tileAY;

        yield return new WaitForSeconds(_swapDuration);
    }

    private int GetRandomTileIndex(int x, int y)
    {
        int randomTile;
        do
        {
            CommandSaveLoadRandomState commandSaveLoadRandomState =
                new CommandSaveLoadRandomState(0, _tiles.Length);
            _boardCommandManager.AddAndDoCommand(commandSaveLoadRandomState);
            randomTile = commandSaveLoadRandomState.result;
        } while (CreatesInitialMatch(x, y, randomTile));

        return randomTile;
    }

    private bool CreatesInitialMatch(int x, int y, int tileType)
    {
        if (x > 1 && tileType == _tileMatrix[x - 1, y]?.tileType && tileType == _tileMatrix[x - 2, y]?.tileType)
        {
            return true;
        }

        if (y > 1 && tileType == _tileMatrix[x, y - 1]?.tileType && tileType == _tileMatrix[x, y - 2]?.tileType)
        {
            return true;
        }

        return false;
    }

    internal void SetTileSprite(GameObject tileObject, int tileIndex)
    {
        SpriteRenderer renderer = tileObject.GetComponentInChildren<SpriteRenderer>();
        var prefabTile = _tiles[tileIndex].GetComponentInChildren<SpriteRenderer>();
        renderer.sprite = prefabTile.sprite;
        renderer.color = prefabTile.color;
    }
} 
File: UIManager.cs 
﻿using TMPro;
using UnityEngine;

public class UIManager : MonoBehaviour
{
    public TextMeshProUGUI scoreText;
    public TextMeshProUGUI movesText;
    public TextMeshProUGUI timeText;
    public TextMeshProUGUI levelText;
    public TextMeshProUGUI targetScoreText;

    private GameModel _gameModel;

    void Start()
    {
        _gameModel = FindObjectOfType<GameModel>();
        _gameModel.OnScoreChanged.AddListener(UpdateScoreText);    }

    void Update()
    {
        RefreshUI();
    }

    private void RefreshUI()
    {
        movesText.text = $"Moves: {_gameModel.moves}";
        timeText.text = $"Time: {_gameModel.remainingTime:F0}s";
        levelText.text = $"Level: {_gameModel.CurrentLevel + 1}";
        targetScoreText.text = $"Target: {_gameModel.levels[_gameModel.CurrentLevel].targetScore}";
    }
    
    public void UpdateScoreText(int newScore)
    {
        scoreText.text = $"Score: {newScore}";
    }
} 
File: VictoryCondition.cs 
﻿using UnityEngine;

[System.Serializable]
[CreateAssetMenu(menuName = "VictoryCondition/Base")]
public abstract class VictoryCondition : ScriptableObject
{
    public abstract bool IsConditionMet(GameModel model);
} 
